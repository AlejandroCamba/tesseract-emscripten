<script src="madeline.js"></script>
<canvas id="c"></canvas>
<script>
var Module = Tesseract304({
	TOTAL_MEMORY: 64e6,
	TesseractProgress: function(percent){
		console.log(percent)
	}
});


var canvas = document.getElementById('c')
canvas.width = 400
var ctx = canvas.getContext('2d');
ctx.font = '30px "Arial Black"'
ctx.fillText('Hello World', 100, 40)
// ctx.fillText("囚犯離奇掙脫囚犯離奇掙脫", 100, 40)
ctx.font = '30px "Times New Roman"'
ctx.fillText('from beyond', 100, 80)
// ctx.fillText('2小時可換乘2次2小時可換乘2次', 100, 80)
ctx.font = '30px sans-serif'
ctx.fillText('the Cosmic Void', 100, 120)
// ctx.fillText('半途殺警逃逸半途殺警逃逸', 100, 120)


// loadLanguage('./tessdata/chi_sim.traineddata', function(err, result){
// 	if(err) console.error("error loading language");
// 	console.log('loaded language')
// 	// runOCR()
// })

loadLanguage('./tessdata/eng.traineddata', function(err, result){
	if(err) console.error("error loading language");
	console.log('loaded language')
	runOCR()
})


function loadLanguage(path, cb){ // NodeJS style callback
	Module.FS_createPath("/","tessdata",true,true)
	var xhr = new XMLHttpRequest();
	xhr.open('GET', path, true);
	xhr.responseType = 'arraybuffer';
	xhr.onerror = function(){ cb(xhr, null) }
	xhr.onload = function(){
		if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) {
			var arr = new Uint8Array(xhr.response)
			Module.FS_createDataFile('tessdata', path.replace(/^.*\//, ''), arr, true, false);
			cb(null, xhr.response)
		} else cb(xhr, null);
	}
	xhr.send(null)
}

function runOCR(){
	var stuff = new Uint8Array(canvas.width * canvas.height)
	var dat = ctx.getImageData(0, 0, canvas.width, canvas.height)
	for(var i = 0; i < stuff.length; i++) stuff[i] = dat.data[i * 4 + 3];
	var stuffptr = Module.allocate(stuff, 'i8', Module.ALLOC_NORMAL);
	console.log('allocated image')
	base = new Module.TessBaseAPI()
	base.Init(null, 'eng')
	console.log('loaded language')
	// base.SetVariable("tessedit_char_blacklist", "xyz");
	// base.SetVariable("tessedit_char_whitelist", "1234567890");
	// it looks like numeric mode still includes non-alphabetic characters
	// like {}$[]
	// base.SetVariable("classify_bln_numeric_mode", "1");
	base.SetImage(Module.wrapPointer(stuffptr), canvas.width, canvas.height, 1, canvas.width)
	base.SetRectangle(0, 0, canvas.width, canvas.height)
	var text = base.GetUTF8Text()
	console.log(text)
	getContours()
	DisplayWords()

	
	// base.End();
	// Module.destroy(base)
	// Module._free(stuffptr);
}




function DisplayWords(){
	var new_canvas = document.createElement('canvas')
	new_canvas.width = canvas.width
	new_canvas.height = canvas.height
	document.body.appendChild(new_canvas)
	var new_ctx = new_canvas.getContext('2d')

	var ri = base.GetIterator();
	do {

		var bb = getBoundingBox(ri, Module.RIL_WORD)

		var confidence = ri.Confidence(Module.RIL_WORD) / 100;
		new_ctx.fillStyle = '#FFA100'
		new_ctx.fillRect(bb.x0, bb.y0, (bb.x1 - bb.x0 + 1) * confidence, bb.y1 - bb.y0 + 1)

		
		new_ctx.strokeStyle = 'green'
		new_ctx.strokeRect(bb.x0, bb.y0, bb.x1 - bb.x0 + 1, bb.y1 - bb.y0 + 1)
		

		var text = ri.GetUTF8Text(Module.RIL_WORD);
		var f = getFontInfo(ri)
		new_ctx.textBaseline = 'hanging'
		new_ctx.fillStyle = 'black'
		var MAGIC_NUMBER_PULLED_OUT_OF_MY_ASS = Math.E; // TODO: find a solid theoretical foundation for this
		new_ctx.font = (f.is_italic ? 'italic' : 'normal') + ' ' +
						(f.is_smallcaps ? 'small-caps': 'normal') + ' ' +
						(f.is_bold ? 'bold' : 'normal') + ' ' +
						(MAGIC_NUMBER_PULLED_OUT_OF_MY_ASS * f.pointsize) + 'pt' + ' ' +
						'"' + f.font_name.replace(/_/g, ' ').replace(/Bold/, '').trim() + '"';

		// console.log(f)
		new_ctx.fillText(text, bb.x0, bb.y0)
		
		document.body.appendChild(document.createElement('hr'))
		var si = new Module.ResultIterator(ri); // clone the iterator
		do {
			// console.log(si.GetUTF8Text(Module.RIL_SYMBOL))
			var block = document.createElement('table')
			block.style.display = 'inline-block'

			var ci = new Module.ChoiceIterator(si);
			do {
				var row = document.createElement('tr')
				var confidence = document.createElement('td');
				var bar = document.createElement('progress')
				bar.value = ci.Confidence() / 100
				bar.style.width = '50px'
				confidence.appendChild(bar)
				row.appendChild(confidence)
				var letter = document.createElement('td')
				letter.appendChild(document.createTextNode(ci.GetUTF8Text()))
				row.appendChild(letter)
				block.appendChild(row)
			} while (ci.Next());
			Module.destroy(ci)
			document.body.appendChild(block)
			// go through each letter in word, stopping at next word
		} while (si.Next(Module.RIL_SYMBOL) && !si.IsAtBeginningOf(Module.RIL_WORD))
		Module.destroy(si);

	}while(ri.Next(Module.RIL_WORD));
	Module.destroy(ri);

}


function getBoundingBox(ri, level){
	var pt = new Module.pointerHelper();
	ri.BoundingBox(level, pt.i32('x0'), pt.i32('y0'), pt.i32('x1'), pt.i32('y1'));
	return pt.get();
}


// TODO; figure out how to fit enums into the new PointerHelper API
function getOrientation(){
	// pi.Orientation(pt.enum('ORIENTATION'))
	var pi = base.AnalyseLayout();
	var ptr = Module._malloc(4*4);
	pi.Orientation(Module.wrapPointer(ptr, Module.Orientation),
				   Module.wrapPointer(ptr + 4, Module.WritingDirection),
				   Module.wrapPointer(ptr + 4 * 2, Module.TextlineOrder),
				   Module.wrapPointer(ptr + 4 * 3, Module.FloatPtr))
	var obj = {
		Orientation: enumToString(Module.getValue(ptr, 'i32'), 'ORIENTATION'),
		WritingDirection: enumToString(Module.getValue(ptr + 4, 'i32'), 'WRITING_DIRECTION'),
		TextlineOrder: enumToString(Module.getValue(ptr + 4 * 2, 'i32'), 'TEXTLINE_ORDER'),
		AngleRadians: Module.getValue(ptr + 4 * 3, 'float')
	}
	Module._free(ptr)
	return obj;
}

function enumToString(value, prefix){
	return (Object.keys(Module)
		.filter(function(e){ return e.startsWith(prefix + '_') })
		.filter(function(e){ return Module[e] === value })
		.map(function(e){ return e.slice(prefix.length + 1) })[0])
}

// page iterators are subclassed by result iterators
// so you can just pass that instead
function getBaseline(pi, pil){ // pi is the page iterator
	var pt = new Module.pointerHelper();
	var has_baseline = !!pi.Baseline(pil || Module.RIL_BLOCK,
						pt.i32('x0'), pt.i32('y0'),
						pt.i32('x1'), pt.i32('y1'));
	var obj = pt.get();
	obj.has_baseline = has_baseline;
	return obj;
}


// Returns the font attributes of the current word. If iterating at a higher
// level object than words, eg textlines, then this will return the
// attributes of the first word in that textline.
// The actual return value is a string representing a font name. It points
// to an internal table and SHOULD NOT BE DELETED. Lifespan is the same as
// the iterator itself, ie rendered invalid by various members of
// TessBaseAPI, including Init, SetImage, End or deleting the TessBaseAPI.
// Pointsize is returned in printers points (1/72 inch.)

function getFontInfo(ri){ // ri is result iterator
	var pt = new Module.pointerHelper();
	var fontName = ri.WordFontAttributes(pt.bool('is_bold'),
										 pt.bool('is_italic'),
										 pt.bool('is_underlined'),
										 pt.bool('is_monospace'),
										 pt.bool('is_serif'),
										 pt.bool('is_smallcaps'),
										 pt.i32('pointsize'),
										 pt.i32('font_id'));
	var obj = pt.peek()
	obj.font_name = fontName;
	return obj;
}

function getContours(){
	var pixapt = Module.wrapPointer(Module._malloc(4), Module.PixaPtr)
	var boxa = base.GetConnectedComponents(pixapt)
	var pixa = Module.wrapPointer(pixapt.get(), Module.Pixa)
	console.assert(pixa.get_n() == boxa.get_n())
	
	var numcc = pixa.get_n();
	ctx.strokeStyle = '#8282E8';
	for(var i = 0; i < numcc; i++){
		var pixxy = Module.wrapPointer(pixa.get_pix().get(i), Module.Pix);
		var boxxy = Module.wrapPointer(boxa.get_box().get(i), Module.Box);
		// console.log('box', boxxy.get_x(), boxxy.get_y(), boxxy.get_w(), boxxy.get_h())
		ctx.strokeRect(boxxy.get_x(), boxxy.get_y(), boxxy.get_w(), boxxy.get_h())
		// console.log('pix', pixxy.get_w(), pixxy.get_h(), pixxy.get_data());
		drawBitPix(pixxy)
	}
	Module._pixaDestroy(Module.getPointer(pixa))
	Module._boxaDestroy(Module.getPointer(boxa))
}


// this draws a bit depth 1 pix from leptonica's internal memory format

function drawBitPix(pix){
	var depth = pix.get_d(),
		wpl = pix.get_wpl(),
		width = pix.get_w(),
		height = pix.get_h();
	
	console.assert(depth == 1)
	console.assert(width > 0)
	console.assert(height > 0)
	console.assert(wpl > 0)

	var data = pix.get_data();
	var imdata = ctx.createImageData(wpl * 4 * 8, height);

	for(var i = 0; i < height; i++){
		for(var j = 0; j < wpl; j++){
			var bs = Module.getValue(data + wpl * 4 * i + j * 4, 'i32');
			for(var k = 0; k < 8 * 4; k++){
				var val = (bs >> k) & 1;
				var x = j * 8 * 4 + k,
					y = i;
				var offset = 4 * ((imdata.width - x) + y * imdata.width);
				imdata.data[offset] = imdata.data[offset + 1] = imdata.data[offset + 2] = val ? 0 : 255
				imdata.data[offset + 3] = 255;
			}
		}
	}
	var new_canvas = document.createElement('canvas')
	new_canvas.width = width
	new_canvas.height = height
	var new_ctx = new_canvas.getContext('2d')
	new_ctx.putImageData(imdata, 0, 0)
	document.body.appendChild(new_canvas)
}


</script>